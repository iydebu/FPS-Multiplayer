#include "pch-cpp.hpp"

#ifndef _MSC_VER
# include <alloca.h>
#else
# include <malloc.h>
#endif


#include <limits>






IL2CPP_EXTERN_C_BEGIN
IL2CPP_EXTERN_C_END

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Winvalid-offsetof"
#pragma clang diagnostic ignored "-Wunused-variable"
#endif

// <Module>
struct U3CModuleU3E_t36ADDCC73490E4AEB903D43A80B98B4E59EEFF31 
{
};

// System.ValueType
struct ValueType_t6D9B272BD21782F0A9A14F2E41F85A50E97A986F  : public RuntimeObject
{
};
// Native definition for P/Invoke marshalling of System.ValueType
struct ValueType_t6D9B272BD21782F0A9A14F2E41F85A50E97A986F_marshaled_pinvoke
{
};
// Native definition for COM marshalling of System.ValueType
struct ValueType_t6D9B272BD21782F0A9A14F2E41F85A50E97A986F_marshaled_com
{
};

// emotitron.Compression.ByteConverter
struct ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B 
{
	union
	{
		#pragma pack(push, tp, 1)
		struct
		{
			// System.Single emotitron.Compression.ByteConverter::float32
			float ___float32_0;
		};
		#pragma pack(pop, tp)
		struct
		{
			float ___float32_0_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			// System.Double emotitron.Compression.ByteConverter::float64
			double ___float64_1;
		};
		#pragma pack(pop, tp)
		struct
		{
			double ___float64_1_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			// System.SByte emotitron.Compression.ByteConverter::int8
			int8_t ___int8_2;
		};
		#pragma pack(pop, tp)
		struct
		{
			int8_t ___int8_2_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			// System.Int16 emotitron.Compression.ByteConverter::int16
			int16_t ___int16_3;
		};
		#pragma pack(pop, tp)
		struct
		{
			int16_t ___int16_3_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			// System.UInt16 emotitron.Compression.ByteConverter::uint16
			uint16_t ___uint16_4;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint16_t ___uint16_4_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			// System.Char emotitron.Compression.ByteConverter::character
			Il2CppChar ___character_5;
		};
		#pragma pack(pop, tp)
		struct
		{
			Il2CppChar ___character_5_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			// System.Int32 emotitron.Compression.ByteConverter::int32
			int32_t ___int32_6;
		};
		#pragma pack(pop, tp)
		struct
		{
			int32_t ___int32_6_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			// System.UInt32 emotitron.Compression.ByteConverter::uint32
			uint32_t ___uint32_7;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint32_t ___uint32_7_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			// System.Int64 emotitron.Compression.ByteConverter::int64
			int64_t ___int64_8;
		};
		#pragma pack(pop, tp)
		struct
		{
			int64_t ___int64_8_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			// System.UInt64 emotitron.Compression.ByteConverter::uint64
			uint64_t ___uint64_9;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint64_t ___uint64_9_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			// System.Byte emotitron.Compression.ByteConverter::byte0
			uint8_t ___byte0_10;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint8_t ___byte0_10_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte1_11_OffsetPadding[1];
			// System.Byte emotitron.Compression.ByteConverter::byte1
			uint8_t ___byte1_11;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte1_11_OffsetPadding_forAlignmentOnly[1];
			uint8_t ___byte1_11_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte2_12_OffsetPadding[2];
			// System.Byte emotitron.Compression.ByteConverter::byte2
			uint8_t ___byte2_12;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte2_12_OffsetPadding_forAlignmentOnly[2];
			uint8_t ___byte2_12_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte3_13_OffsetPadding[3];
			// System.Byte emotitron.Compression.ByteConverter::byte3
			uint8_t ___byte3_13;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte3_13_OffsetPadding_forAlignmentOnly[3];
			uint8_t ___byte3_13_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte4_14_OffsetPadding[4];
			// System.Byte emotitron.Compression.ByteConverter::byte4
			uint8_t ___byte4_14;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte4_14_OffsetPadding_forAlignmentOnly[4];
			uint8_t ___byte4_14_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte5_15_OffsetPadding[5];
			// System.Byte emotitron.Compression.ByteConverter::byte5
			uint8_t ___byte5_15;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte5_15_OffsetPadding_forAlignmentOnly[5];
			uint8_t ___byte5_15_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte6_16_OffsetPadding[6];
			// System.Byte emotitron.Compression.ByteConverter::byte6
			uint8_t ___byte6_16;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte6_16_OffsetPadding_forAlignmentOnly[6];
			uint8_t ___byte6_16_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte7_17_OffsetPadding[7];
			// System.Byte emotitron.Compression.ByteConverter::byte7
			uint8_t ___byte7_17;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte7_17_OffsetPadding_forAlignmentOnly[7];
			uint8_t ___byte7_17_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___uint16_B_18_OffsetPadding[4];
			// System.UInt32 emotitron.Compression.ByteConverter::uint16_B
			uint32_t ___uint16_B_18;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___uint16_B_18_OffsetPadding_forAlignmentOnly[4];
			uint32_t ___uint16_B_18_forAlignmentOnly;
		};
	};
};
// Native definition for P/Invoke marshalling of emotitron.Compression.ByteConverter
struct ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B_marshaled_pinvoke
{
	union
	{
		#pragma pack(push, tp, 1)
		struct
		{
			float ___float32_0;
		};
		#pragma pack(pop, tp)
		struct
		{
			float ___float32_0_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			double ___float64_1;
		};
		#pragma pack(pop, tp)
		struct
		{
			double ___float64_1_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			int8_t ___int8_2;
		};
		#pragma pack(pop, tp)
		struct
		{
			int8_t ___int8_2_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			int16_t ___int16_3;
		};
		#pragma pack(pop, tp)
		struct
		{
			int16_t ___int16_3_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			uint16_t ___uint16_4;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint16_t ___uint16_4_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			uint8_t ___character_5;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint8_t ___character_5_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			int32_t ___int32_6;
		};
		#pragma pack(pop, tp)
		struct
		{
			int32_t ___int32_6_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			uint32_t ___uint32_7;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint32_t ___uint32_7_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			int64_t ___int64_8;
		};
		#pragma pack(pop, tp)
		struct
		{
			int64_t ___int64_8_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			uint64_t ___uint64_9;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint64_t ___uint64_9_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			uint8_t ___byte0_10;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint8_t ___byte0_10_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte1_11_OffsetPadding[1];
			uint8_t ___byte1_11;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte1_11_OffsetPadding_forAlignmentOnly[1];
			uint8_t ___byte1_11_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte2_12_OffsetPadding[2];
			uint8_t ___byte2_12;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte2_12_OffsetPadding_forAlignmentOnly[2];
			uint8_t ___byte2_12_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte3_13_OffsetPadding[3];
			uint8_t ___byte3_13;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte3_13_OffsetPadding_forAlignmentOnly[3];
			uint8_t ___byte3_13_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte4_14_OffsetPadding[4];
			uint8_t ___byte4_14;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte4_14_OffsetPadding_forAlignmentOnly[4];
			uint8_t ___byte4_14_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte5_15_OffsetPadding[5];
			uint8_t ___byte5_15;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte5_15_OffsetPadding_forAlignmentOnly[5];
			uint8_t ___byte5_15_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte6_16_OffsetPadding[6];
			uint8_t ___byte6_16;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte6_16_OffsetPadding_forAlignmentOnly[6];
			uint8_t ___byte6_16_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte7_17_OffsetPadding[7];
			uint8_t ___byte7_17;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte7_17_OffsetPadding_forAlignmentOnly[7];
			uint8_t ___byte7_17_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___uint16_B_18_OffsetPadding[4];
			uint32_t ___uint16_B_18;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___uint16_B_18_OffsetPadding_forAlignmentOnly[4];
			uint32_t ___uint16_B_18_forAlignmentOnly;
		};
	};
};
// Native definition for COM marshalling of emotitron.Compression.ByteConverter
struct ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B_marshaled_com
{
	union
	{
		#pragma pack(push, tp, 1)
		struct
		{
			float ___float32_0;
		};
		#pragma pack(pop, tp)
		struct
		{
			float ___float32_0_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			double ___float64_1;
		};
		#pragma pack(pop, tp)
		struct
		{
			double ___float64_1_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			int8_t ___int8_2;
		};
		#pragma pack(pop, tp)
		struct
		{
			int8_t ___int8_2_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			int16_t ___int16_3;
		};
		#pragma pack(pop, tp)
		struct
		{
			int16_t ___int16_3_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			uint16_t ___uint16_4;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint16_t ___uint16_4_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			uint8_t ___character_5;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint8_t ___character_5_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			int32_t ___int32_6;
		};
		#pragma pack(pop, tp)
		struct
		{
			int32_t ___int32_6_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			uint32_t ___uint32_7;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint32_t ___uint32_7_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			int64_t ___int64_8;
		};
		#pragma pack(pop, tp)
		struct
		{
			int64_t ___int64_8_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			uint64_t ___uint64_9;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint64_t ___uint64_9_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			uint8_t ___byte0_10;
		};
		#pragma pack(pop, tp)
		struct
		{
			uint8_t ___byte0_10_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte1_11_OffsetPadding[1];
			uint8_t ___byte1_11;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte1_11_OffsetPadding_forAlignmentOnly[1];
			uint8_t ___byte1_11_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte2_12_OffsetPadding[2];
			uint8_t ___byte2_12;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte2_12_OffsetPadding_forAlignmentOnly[2];
			uint8_t ___byte2_12_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte3_13_OffsetPadding[3];
			uint8_t ___byte3_13;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte3_13_OffsetPadding_forAlignmentOnly[3];
			uint8_t ___byte3_13_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte4_14_OffsetPadding[4];
			uint8_t ___byte4_14;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte4_14_OffsetPadding_forAlignmentOnly[4];
			uint8_t ___byte4_14_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte5_15_OffsetPadding[5];
			uint8_t ___byte5_15;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte5_15_OffsetPadding_forAlignmentOnly[5];
			uint8_t ___byte5_15_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte6_16_OffsetPadding[6];
			uint8_t ___byte6_16;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte6_16_OffsetPadding_forAlignmentOnly[6];
			uint8_t ___byte6_16_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___byte7_17_OffsetPadding[7];
			uint8_t ___byte7_17;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___byte7_17_OffsetPadding_forAlignmentOnly[7];
			uint8_t ___byte7_17_forAlignmentOnly;
		};
		#pragma pack(push, tp, 1)
		struct
		{
			char ___uint16_B_18_OffsetPadding[4];
			uint32_t ___uint16_B_18;
		};
		#pragma pack(pop, tp)
		struct
		{
			char ___uint16_B_18_OffsetPadding_forAlignmentOnly[4];
			uint32_t ___uint16_B_18_forAlignmentOnly;
		};
	};
};

// System.Single
struct Single_t4530F2FF86FCB0DC29F35385CA1BD21BE294761C 
{
	// System.Single System.Single::m_value
	float ___m_value_0;
};

// System.UInt32
struct UInt32_t1833D51FFA667B18A5AA4B8D34DE284F8495D29B 
{
	// System.UInt32 System.UInt32::m_value
	uint32_t ___m_value_0;
};

// <Module>

// <Module>

// emotitron.Compression.ByteConverter

// emotitron.Compression.ByteConverter

// System.Single

// System.Single

// System.UInt32

// System.UInt32
#ifdef __clang__
#pragma clang diagnostic pop
#endif



#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Winvalid-offsetof"
#pragma clang diagnostic ignored "-Wunused-variable"
#endif
#ifdef __clang__
#pragma clang diagnostic pop
#endif
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Winvalid-offsetof"
#pragma clang diagnostic ignored "-Wunused-variable"
#endif
// Conversion methods for marshalling of: emotitron.Compression.ByteConverter
IL2CPP_EXTERN_C void ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B_marshal_pinvoke(const ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B& unmarshaled, ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B_marshaled_pinvoke& marshaled)
{
	marshaled.___float32_0 = unmarshaled.___float32_0;
	marshaled.___float64_1 = unmarshaled.___float64_1;
	marshaled.___int8_2 = unmarshaled.___int8_2;
	marshaled.___int16_3 = unmarshaled.___int16_3;
	marshaled.___uint16_4 = unmarshaled.___uint16_4;
	marshaled.___character_5 = static_cast<uint8_t>(unmarshaled.___character_5);
	marshaled.___int32_6 = unmarshaled.___int32_6;
	marshaled.___uint32_7 = unmarshaled.___uint32_7;
	marshaled.___int64_8 = unmarshaled.___int64_8;
	marshaled.___uint64_9 = unmarshaled.___uint64_9;
	marshaled.___byte0_10 = unmarshaled.___byte0_10;
	marshaled.___byte1_11 = unmarshaled.___byte1_11;
	marshaled.___byte2_12 = unmarshaled.___byte2_12;
	marshaled.___byte3_13 = unmarshaled.___byte3_13;
	marshaled.___byte4_14 = unmarshaled.___byte4_14;
	marshaled.___byte5_15 = unmarshaled.___byte5_15;
	marshaled.___byte6_16 = unmarshaled.___byte6_16;
	marshaled.___byte7_17 = unmarshaled.___byte7_17;
	marshaled.___uint16_B_18 = unmarshaled.___uint16_B_18;
}
IL2CPP_EXTERN_C void ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B_marshal_pinvoke_back(const ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B_marshaled_pinvoke& marshaled, ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B& unmarshaled)
{
	float unmarshaledfloat32_temp_0 = 0.0f;
	unmarshaledfloat32_temp_0 = marshaled.___float32_0;
	unmarshaled.___float32_0 = unmarshaledfloat32_temp_0;
	double unmarshaledfloat64_temp_1 = 0.0;
	unmarshaledfloat64_temp_1 = marshaled.___float64_1;
	unmarshaled.___float64_1 = unmarshaledfloat64_temp_1;
	int8_t unmarshaledint8_temp_2 = 0x0;
	unmarshaledint8_temp_2 = marshaled.___int8_2;
	unmarshaled.___int8_2 = unmarshaledint8_temp_2;
	int16_t unmarshaledint16_temp_3 = 0;
	unmarshaledint16_temp_3 = marshaled.___int16_3;
	unmarshaled.___int16_3 = unmarshaledint16_temp_3;
	uint16_t unmarshaleduint16_temp_4 = 0;
	unmarshaleduint16_temp_4 = marshaled.___uint16_4;
	unmarshaled.___uint16_4 = unmarshaleduint16_temp_4;
	Il2CppChar unmarshaledcharacter_temp_5 = 0x0;
	unmarshaledcharacter_temp_5 = static_cast<Il2CppChar>(marshaled.___character_5);
	unmarshaled.___character_5 = unmarshaledcharacter_temp_5;
	int32_t unmarshaledint32_temp_6 = 0;
	unmarshaledint32_temp_6 = marshaled.___int32_6;
	unmarshaled.___int32_6 = unmarshaledint32_temp_6;
	uint32_t unmarshaleduint32_temp_7 = 0;
	unmarshaleduint32_temp_7 = marshaled.___uint32_7;
	unmarshaled.___uint32_7 = unmarshaleduint32_temp_7;
	int64_t unmarshaledint64_temp_8 = 0;
	unmarshaledint64_temp_8 = marshaled.___int64_8;
	unmarshaled.___int64_8 = unmarshaledint64_temp_8;
	uint64_t unmarshaleduint64_temp_9 = 0;
	unmarshaleduint64_temp_9 = marshaled.___uint64_9;
	unmarshaled.___uint64_9 = unmarshaleduint64_temp_9;
	uint8_t unmarshaledbyte0_temp_10 = 0x0;
	unmarshaledbyte0_temp_10 = marshaled.___byte0_10;
	unmarshaled.___byte0_10 = unmarshaledbyte0_temp_10;
	uint8_t unmarshaledbyte1_temp_11 = 0x0;
	unmarshaledbyte1_temp_11 = marshaled.___byte1_11;
	unmarshaled.___byte1_11 = unmarshaledbyte1_temp_11;
	uint8_t unmarshaledbyte2_temp_12 = 0x0;
	unmarshaledbyte2_temp_12 = marshaled.___byte2_12;
	unmarshaled.___byte2_12 = unmarshaledbyte2_temp_12;
	uint8_t unmarshaledbyte3_temp_13 = 0x0;
	unmarshaledbyte3_temp_13 = marshaled.___byte3_13;
	unmarshaled.___byte3_13 = unmarshaledbyte3_temp_13;
	uint8_t unmarshaledbyte4_temp_14 = 0x0;
	unmarshaledbyte4_temp_14 = marshaled.___byte4_14;
	unmarshaled.___byte4_14 = unmarshaledbyte4_temp_14;
	uint8_t unmarshaledbyte5_temp_15 = 0x0;
	unmarshaledbyte5_temp_15 = marshaled.___byte5_15;
	unmarshaled.___byte5_15 = unmarshaledbyte5_temp_15;
	uint8_t unmarshaledbyte6_temp_16 = 0x0;
	unmarshaledbyte6_temp_16 = marshaled.___byte6_16;
	unmarshaled.___byte6_16 = unmarshaledbyte6_temp_16;
	uint8_t unmarshaledbyte7_temp_17 = 0x0;
	unmarshaledbyte7_temp_17 = marshaled.___byte7_17;
	unmarshaled.___byte7_17 = unmarshaledbyte7_temp_17;
	uint32_t unmarshaleduint16_B_temp_18 = 0;
	unmarshaleduint16_B_temp_18 = marshaled.___uint16_B_18;
	unmarshaled.___uint16_B_18 = unmarshaleduint16_B_temp_18;
}
// Conversion method for clean up from marshalling of: emotitron.Compression.ByteConverter
IL2CPP_EXTERN_C void ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B_marshal_pinvoke_cleanup(ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B_marshaled_pinvoke& marshaled)
{
}
// Conversion methods for marshalling of: emotitron.Compression.ByteConverter
IL2CPP_EXTERN_C void ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B_marshal_com(const ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B& unmarshaled, ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B_marshaled_com& marshaled)
{
	marshaled.___float32_0 = unmarshaled.___float32_0;
	marshaled.___float64_1 = unmarshaled.___float64_1;
	marshaled.___int8_2 = unmarshaled.___int8_2;
	marshaled.___int16_3 = unmarshaled.___int16_3;
	marshaled.___uint16_4 = unmarshaled.___uint16_4;
	marshaled.___character_5 = static_cast<uint8_t>(unmarshaled.___character_5);
	marshaled.___int32_6 = unmarshaled.___int32_6;
	marshaled.___uint32_7 = unmarshaled.___uint32_7;
	marshaled.___int64_8 = unmarshaled.___int64_8;
	marshaled.___uint64_9 = unmarshaled.___uint64_9;
	marshaled.___byte0_10 = unmarshaled.___byte0_10;
	marshaled.___byte1_11 = unmarshaled.___byte1_11;
	marshaled.___byte2_12 = unmarshaled.___byte2_12;
	marshaled.___byte3_13 = unmarshaled.___byte3_13;
	marshaled.___byte4_14 = unmarshaled.___byte4_14;
	marshaled.___byte5_15 = unmarshaled.___byte5_15;
	marshaled.___byte6_16 = unmarshaled.___byte6_16;
	marshaled.___byte7_17 = unmarshaled.___byte7_17;
	marshaled.___uint16_B_18 = unmarshaled.___uint16_B_18;
}
IL2CPP_EXTERN_C void ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B_marshal_com_back(const ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B_marshaled_com& marshaled, ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B& unmarshaled)
{
	float unmarshaledfloat32_temp_0 = 0.0f;
	unmarshaledfloat32_temp_0 = marshaled.___float32_0;
	unmarshaled.___float32_0 = unmarshaledfloat32_temp_0;
	double unmarshaledfloat64_temp_1 = 0.0;
	unmarshaledfloat64_temp_1 = marshaled.___float64_1;
	unmarshaled.___float64_1 = unmarshaledfloat64_temp_1;
	int8_t unmarshaledint8_temp_2 = 0x0;
	unmarshaledint8_temp_2 = marshaled.___int8_2;
	unmarshaled.___int8_2 = unmarshaledint8_temp_2;
	int16_t unmarshaledint16_temp_3 = 0;
	unmarshaledint16_temp_3 = marshaled.___int16_3;
	unmarshaled.___int16_3 = unmarshaledint16_temp_3;
	uint16_t unmarshaleduint16_temp_4 = 0;
	unmarshaleduint16_temp_4 = marshaled.___uint16_4;
	unmarshaled.___uint16_4 = unmarshaleduint16_temp_4;
	Il2CppChar unmarshaledcharacter_temp_5 = 0x0;
	unmarshaledcharacter_temp_5 = static_cast<Il2CppChar>(marshaled.___character_5);
	unmarshaled.___character_5 = unmarshaledcharacter_temp_5;
	int32_t unmarshaledint32_temp_6 = 0;
	unmarshaledint32_temp_6 = marshaled.___int32_6;
	unmarshaled.___int32_6 = unmarshaledint32_temp_6;
	uint32_t unmarshaleduint32_temp_7 = 0;
	unmarshaleduint32_temp_7 = marshaled.___uint32_7;
	unmarshaled.___uint32_7 = unmarshaleduint32_temp_7;
	int64_t unmarshaledint64_temp_8 = 0;
	unmarshaledint64_temp_8 = marshaled.___int64_8;
	unmarshaled.___int64_8 = unmarshaledint64_temp_8;
	uint64_t unmarshaleduint64_temp_9 = 0;
	unmarshaleduint64_temp_9 = marshaled.___uint64_9;
	unmarshaled.___uint64_9 = unmarshaleduint64_temp_9;
	uint8_t unmarshaledbyte0_temp_10 = 0x0;
	unmarshaledbyte0_temp_10 = marshaled.___byte0_10;
	unmarshaled.___byte0_10 = unmarshaledbyte0_temp_10;
	uint8_t unmarshaledbyte1_temp_11 = 0x0;
	unmarshaledbyte1_temp_11 = marshaled.___byte1_11;
	unmarshaled.___byte1_11 = unmarshaledbyte1_temp_11;
	uint8_t unmarshaledbyte2_temp_12 = 0x0;
	unmarshaledbyte2_temp_12 = marshaled.___byte2_12;
	unmarshaled.___byte2_12 = unmarshaledbyte2_temp_12;
	uint8_t unmarshaledbyte3_temp_13 = 0x0;
	unmarshaledbyte3_temp_13 = marshaled.___byte3_13;
	unmarshaled.___byte3_13 = unmarshaledbyte3_temp_13;
	uint8_t unmarshaledbyte4_temp_14 = 0x0;
	unmarshaledbyte4_temp_14 = marshaled.___byte4_14;
	unmarshaled.___byte4_14 = unmarshaledbyte4_temp_14;
	uint8_t unmarshaledbyte5_temp_15 = 0x0;
	unmarshaledbyte5_temp_15 = marshaled.___byte5_15;
	unmarshaled.___byte5_15 = unmarshaledbyte5_temp_15;
	uint8_t unmarshaledbyte6_temp_16 = 0x0;
	unmarshaledbyte6_temp_16 = marshaled.___byte6_16;
	unmarshaled.___byte6_16 = unmarshaledbyte6_temp_16;
	uint8_t unmarshaledbyte7_temp_17 = 0x0;
	unmarshaledbyte7_temp_17 = marshaled.___byte7_17;
	unmarshaled.___byte7_17 = unmarshaledbyte7_temp_17;
	uint32_t unmarshaleduint16_B_temp_18 = 0;
	unmarshaleduint16_B_temp_18 = marshaled.___uint16_B_18;
	unmarshaled.___uint16_B_18 = unmarshaleduint16_B_temp_18;
}
// Conversion method for clean up from marshalling of: emotitron.Compression.ByteConverter
IL2CPP_EXTERN_C void ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B_marshal_com_cleanup(ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B_marshaled_com& marshaled)
{
}
// emotitron.Compression.ByteConverter emotitron.Compression.ByteConverter::op_Implicit(System.UInt32)
IL2CPP_EXTERN_C IL2CPP_METHOD_ATTR ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B ByteConverter_op_Implicit_m13C7416352083C33B9E788309F8C7860E8386066 (uint32_t ___0_val, const RuntimeMethod* method) 
{
	ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B V_0;
	memset((&V_0), 0, sizeof(V_0));
	{
		il2cpp_codegen_initobj((&V_0), sizeof(ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B));
		uint32_t L_0 = ___0_val;
		(&V_0)->___uint32_7 = L_0;
		ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B L_1 = V_0;
		return L_1;
	}
}
// emotitron.Compression.ByteConverter emotitron.Compression.ByteConverter::op_Implicit(System.Single)
IL2CPP_EXTERN_C IL2CPP_METHOD_ATTR ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B ByteConverter_op_Implicit_m38DE78B58128B680373D2C5FF9B8A273B3DF19F8 (float ___0_val, const RuntimeMethod* method) 
{
	ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B V_0;
	memset((&V_0), 0, sizeof(V_0));
	{
		il2cpp_codegen_initobj((&V_0), sizeof(ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B));
		float L_0 = ___0_val;
		(&V_0)->___float32_0 = L_0;
		ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B L_1 = V_0;
		return L_1;
	}
}
// System.UInt32 emotitron.Compression.ByteConverter::op_Implicit(emotitron.Compression.ByteConverter)
IL2CPP_EXTERN_C IL2CPP_METHOD_ATTR uint32_t ByteConverter_op_Implicit_mD95D8608CB49CC76C3B9DAEBF5812F6936CF89DA (ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B ___0_bc, const RuntimeMethod* method) 
{
	{
		ByteConverter_t6EBE1850B2EAFEEC97D949413681A8E3862D831B L_0 = ___0_bc;
		uint32_t L_1 = L_0.___uint32_7;
		return L_1;
	}
}
#ifdef __clang__
#pragma clang diagnostic pop
#endif
